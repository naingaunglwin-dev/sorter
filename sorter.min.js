/**
 * @copyright (c) Naing Aung Lwin
 * @link https://github.com/naingaunglwin-dev/sorter
 * @package sorter/sorter (Minified)
 * @license MIT License
 */

/**
 * sorter - Utility for sorting data and select options based on specified conditions.
 * <p>@param a Selector element</p>
 * <p>@param e data</p>
 * <p>@param t sorting type</p>
 * @returns {Object} An object containing sorting methods for numbers, alphabets, and select elements.
 */
function sorter(){const e={n_asc:"num-asc",n_desc:"num-desc",a_asc:"alpha-asc",a_desc:"alpha-desc",n_asc_a_asc:"num-asc-alpha-asc",n_asc_a_desc:"num-asc-alpha-desc",n_desc_a_asc:"num-desc-alpha-asc",n_desc_a_desc:"num-desc-alpha-desc",a_asc_n_asc:"alpha-asc-num-asc",a_asc_n_desc:"alpha-asc-num-desc",a_desc_n_asc:"alpha-desc-num-asc",a_desc_n_desc:"alpha-desc-num-desc"},a={n_asc:e.n_asc,n_desc:e.n_desc},t={a_asc:e.a_asc,a_desc:e.a_desc};return{number:(e,t)=>{if("object"!=typeof e||e===[])throw new Error("Data must be array type and not be empty");if(!Object.values(a).includes(t))throw new Error("Unsupported Condition Type");if(e.every((e=>"number"==typeof e&&!Number.isNaN(e))))throw new Error("Data array must contain only numbers");return t===a.n_asc?e.sort(((e,a)=>e-a)):t===a.n_desc?e.sort(((e,a)=>a-e)):e.sort(((e,a)=>e-a))},alphabet:(e,a)=>{if("object"!=typeof e||e===[])throw new Error("Data must be array type and not be empty");if(!Object.values(t).includes(a))throw new Error("Unsupported Condition Type");if(e.every((e=>"string"==typeof e)))throw new Error("Data array must contain only string");return a===t.a_asc?e.sort():a===t.a_desc?e.sort(((e,a)=>{let t=e.toUpperCase(),s=a.toUpperCase();return t>s?-1:t<s?1:0})):e.sort()},select:(a,t)=>{let s=document.querySelector(a);if("select"!==s.tagName.toLowerCase())throw new DOMException(`Only Select Tag Allowed, Using ${self.element.tagName.toLowerCase()}`);if(!Object.values(e).includes(t))throw new DOMException("Unsupported Condition Type");const r=Array.from(s.options),o=[],c=[],u=[];r.map((e=>{const a=Number(e.value);isNaN(a)?c.push({text:e.text,value:e.value}):o.push({text:e.text,value:e.value})})),t===e.n_asc?(o.sort(((e,a)=>Number(e.value)-Number(a.value))),u.push(...o,...c)):t===e.n_desc?(o.sort(((e,a)=>Number(a.value)-Number(e.value))),u.push(...o,...c)):t===e.a_asc?(c.sort(((e,a)=>e.text.localeCompare(a.text))),u.push(...c,...o)):t===e.a_desc?(c.sort(((e,a)=>a.text.localeCompare(e.text))),u.push(...c,...o)):t===e.n_asc_a_asc?(o.sort(((e,a)=>Number(e.value)-Number(a.value))),c.sort(((e,a)=>e.text.localeCompare(a.text))),u.push(...o,...c)):t===e.n_asc_a_desc?(o.sort(((e,a)=>Number(e.value)-Number(a.value))),c.sort(((e,a)=>a.text.localeCompare(e.text))),u.push(...o,...c)):t===e.n_desc_a_asc?(o.sort(((e,a)=>Number(a.value)-Number(e.value))),c.sort(((e,a)=>e.text.localeCompare(a.text))),u.push(...o,...c)):t===e.n_desc_a_desc?(o.sort(((e,a)=>Number(a.value)-Number(e.value))),c.sort(((e,a)=>a.text.localeCompare(e.text))),u.push(...o,...c)):t===e.a_asc_n_asc?(c.sort(((e,a)=>e.text.localeCompare(a.text))),o.sort(((e,a)=>Number(e.value)-Number(a.value))),u.push(...c,...o)):t===e.a_asc_n_desc?(c.sort(((e,a)=>e.text.localeCompare(a.text))),o.sort(((e,a)=>Number(a.value)-Number(e.value))),u.push(...c,...o)):t===e.a_desc_n_asc?(c.sort(((e,a)=>a.text.localeCompare(e.text))),o.sort(((e,a)=>Number(e.value)-Number(a.value))),u.push(...c,...o)):t===e.a_desc_n_desc&&(c.sort(((e,a)=>a.text.localeCompare(e.text))),o.sort(((e,a)=>Number(a.value)-Number(e.value))),u.push(...c,...o)),s.innerHTML=u.map((e=>`<option value="${e.value}">${e.text}</option>`)).join("")}}}
